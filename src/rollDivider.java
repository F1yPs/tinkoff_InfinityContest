import java.util.Scanner;
import java.lang.Math;

/**
 * Ваня принес на кухню рулет, который он хочет разделить с коллегами. Для этого он хочет разрезать рулет на ﻿NN﻿ равных частей. Разумеется, рулет можно резать только поперек. Соотвественно, Костя сделает ﻿N−1N−1﻿ разрез ножом через равные промежутки.
 *
 *
 * По возвращению с кофе-брейка Ваня задумался — а можно ли было обойтись меньшим числом движений, будь нож Вани бесконечно длинным (иначе говоря, если он мог бы сделать сколько угодно разрезов за раз, если эти разрезы лежат на одной прямой)? Считается, что места для разрезов намечены заранее, и все разрезы делаются с ювелирной точностью.
 *
 * Оказывается, что можно. Например, если Ваня хотел бы разделить рулет на ﻿44﻿ части, он мог бы обойтись двумя разрезами — сначала он разделил бы рулет на две половинки, а потом совместил бы две половинки и разрезал обе пополам одновременно.
 *
 * Вам дано число ﻿NN﻿, требуется сказать, каким минимальным числом разрезов можно обойтись.
 *
 *
 * Формат входных данных
 *
 * Дано одно натуральное число ﻿N(1≤N≤2×109)N(1≤N≤2×109)﻿ — количество людей на кофе-брйке.
 *
 *
 * Формат выходных данных
 *
 * Выведите одно число — минимальное число движений, которое придется сделать Косте.
 *
 *
 * Замечание
 *
 * Чтобы разрезать рулет на ﻿66﻿ частей, Ване сначала придется разрезать его на две равные части, после чего совместить две половинки и сделать два разреза.
 *
 * Чтобы разрезать рулет на ﻿55﻿ частей, Ване понадобится разделить его в соотношении ﻿2:32:3﻿, после чего совместить два рулета по левому краю и разрезать бОльший рулет на одинарные кусочки — меньший тоже разделится на одинарные.
 */


public class rollDivider {
    public static void main(String[] args) {
        // если рассмотреть разрезы, то можно заметить следующее (N - количество людей)
//        N  должно быть
//        1     0
//        2     1
//        3     2
//        4     2
//        5     3
//        6     3
//        7     3
//        8     3
//        9     4
//          ....
//        16 ...4
//        17 ...5
        Scanner console = new Scanner(System.in);
        int n = console.nextInt();
//        System.out.println((int)Math.ceil(Math.log(n)/Math.log(2))); // через логарфим
        System.out.println(32 - Integer.numberOfLeadingZeros(n - 1)); // через впереди идущих нулей

// то можно заметить, что количество разрезов это log2(N)
    }
}


// решение через итерации
//        Scanner console = new Scanner(System.in);
//        int n = console.nextInt();
//        int countCut = 0;
//        int i = n;
//        while (i > 1) {
//            i = (int) Math.round(i / 2.0);
//            countCut++;
//        }
////        for (int i = n; i > 1; i = (int) Math.round(i/2.0), countCut++) {}
//        System.out.println(countCut);
//    }


// Решение №1 (рекурсия)

//        System.out.println(searchRollDivider(n);
//    private static int searchRollDivider(int n) {
//        if (n == 1) return 0;
//        else return searchRollDivider( Math.ceilDiv(n , 2), 1);
//    }
//
//    private static int searchRollDivider(int n, int count) {
//        if (n == 1) return count;
//        else return searchRollDivider(Math.ceilDiv(n , 2), ++count);
//    }
//}


// https://stackoverflow.com/questions/3305059/how-do-you-calculate-log-base-2-in-java-for-integers
// Сравнение - как получить log по основанию 2
// https://ru.stackoverflow.com/questions/1377642/%D0%A0%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BA%D0%B8